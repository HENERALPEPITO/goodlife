/**
 * Artist Payment Request API
 * POST /api/payment/request
 * 
 * Allows artists to request payment for their unpaid royalties
 */

import { NextRequest, NextResponse } from "next/server";
import { createServerSupabaseClient, getCurrentUser } from "@/lib/authHelpers";
import { supabaseAdmin } from "@/lib/supabaseAdmin";

interface PaymentRequestResponse {
  success: boolean;
  paymentRequest?: {
    id: string;
    total_amount: number;
    royalty_count: number;
  };
  error?: string;
}

export async function POST(request: NextRequest): Promise<NextResponse<PaymentRequestResponse>> {
  try {
    // Get current user
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized. Please login." },
        { status: 401 }
      );
    }

    // Artists can only create requests for themselves
    // Admins can create requests on behalf of artists (optional)
    const artistId = user.id;

    // Get total unpaid royalties for this artist
    const { data: totalData, error: totalError } = await supabaseAdmin
      .rpc("get_unpaid_royalties_total", { artist_uuid: artistId });

    if (totalError) {
      console.error("Error calculating unpaid royalties:", totalError);
      return NextResponse.json(
        { success: false, error: "Failed to calculate unpaid royalties" },
        { status: 500 }
      );
    }

    const totalAmount = parseFloat(totalData || "0");

    // Check if balance meets minimum threshold (€100)
    const MINIMUM_BALANCE = 100;
    if (totalAmount < MINIMUM_BALANCE) {
      return NextResponse.json(
        { 
          success: false, 
          error: `Minimum payout is €${MINIMUM_BALANCE}. You currently have €${totalAmount.toFixed(2)}.` 
        },
        { status: 400 }
      );
    }

    // Check if there's already a pending or approved request
    const { data: existingRequest } = await supabaseAdmin
      .from("payment_requests")
      .select("id, status")
      .eq("artist_id", artistId)
      .in("status", ["pending", "approved"])
      .single();

    if (existingRequest) {
      const statusText = existingRequest.status === "pending" ? "pending" : "approved";
      return NextResponse.json(
        { 
          success: false, 
          error: `You already have a ${statusText} payment request. Only one request can be active at a time.` 
        },
        { status: 400 }
      );
    }

    // Create payment request
    const { data: paymentRequest, error: createError } = await supabaseAdmin
      .from("payment_requests")
      .insert({
        artist_id: artistId,
        amount: totalAmount, // Use 'amount' field (database uses 'amount', not 'total_amount')
        status: "pending",
      })
      .select()
      .single();

    if (createError || !paymentRequest) {
      console.error("Error creating payment request:", createError);
      return NextResponse.json(
        { success: false, error: "Failed to create payment request" },
        { status: 500 }
      );
    }

    // Mark all unpaid royalties as paid (reset balance to €0)
    const { data: royaltyCount, error: markError } = await supabaseAdmin
      .rpc("mark_royalties_as_paid", {
        artist_uuid: artistId,
      });

    if (markError) {
      console.error("Error marking royalties as paid:", markError);
      // Rollback: delete the payment request
      await supabaseAdmin
        .from("payment_requests")
        .delete()
        .eq("id", paymentRequest.id);

      return NextResponse.json(
        { success: false, error: "Failed to process payment request" },
        { status: 500 }
      );
    }

    // Also update paid_status to 'paid' for consistency
    const { error: updateStatusError } = await supabaseAdmin
      .from("royalties")
      .update({ paid_status: "paid" })
      .eq("artist_id", artistId)
      .eq("is_paid", false);

    if (updateStatusError) {
      console.error("Error updating paid_status:", updateStatusError);
      // Don't fail the request, but log the error
    }

    // Invoice is auto-generated by database trigger
    // But we can verify it was created
    const { data: invoice } = await supabaseAdmin
      .from("invoices")
      .select("id, invoice_number")
      .eq("payment_request_id", paymentRequest.id)
      .single();

    return NextResponse.json(
      {
        success: true,
        paymentRequest: {
          id: paymentRequest.id,
          total_amount: totalAmount,
          amount: paymentRequest.amount || totalAmount,
          royalty_count: royaltyCount || 0,
        },
        invoice: invoice ? {
          id: invoice.id,
          invoice_number: invoice.invoice_number,
        } : null,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Unexpected error in payment request API:", error);
    return NextResponse.json(
      { success: false, error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json(
    { error: "Method not allowed" },
    { status: 405 }
  );
}





